---
title: "MoSeq Model Analysis"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


```{r}
#Setup working directory
setwd("C:/Users/nj35/OneDrive - University of St Andrews/Masters/MoSeq R-Analysis")
getwd()
```


```{r}
#download packages for managing r packages and excel
install.packages("pacman")
install.packages("readxl")
install.packages("tidyverse") 
install.packages("emmeans")
install.packages("afex")
install.packages("installr")
install.packages("conflicted")
install.packages("sandwich")
install.packages("lmtest")
install.packages("geepack")
install.packages("tibble")
install.packages("effectsize")
install.packages("lmerTest")
install.packages("robustlmm")
install.packages("clubSandwich")

```

```{r}
#load packages
library(pacman)
library(readxl)
library(tidyverse) #includes ggplot and dplyr
library(tibble)
library(emmeans)
library(conflicted)
library(afex)
library(lme4) #LMM model
library(lmerTest)  # For p-values in LMM
library(Matrix)
library(car)
library(tibble)
library(effectsize)
library(geepack)
library(robustlmm)
library(clubSandwich)

```

```{r}
installr::updateR()
```

# OFT_model

```{r}
#load results file and make sure headings and levels are established

df_oft <- read.csv("new_moseq_OFT_stats.csv", header=TRUE)
df_oft$syllable <- factor(df_oft$syllable)  # Convert to categorical
df_oft$group <- factor(df_oft$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
#cool fact, code above sets "control" as baseline value as it comes first
df_oft$ID <- factor(df_oft$ID)

```

```{r}
conflicted::conflicts_prefer(lmer::afex)

```

```{r}
#compare models
#model_complex <- lmer(frequency ~ syllable * group + (syllable | group), data = df_oft) #With (syllable | group) the model learns different patterns for each group, also not repeated measure don't use.
model_simple <- lm(frequency ~ group * syllable, data = df_oft) #not LMM, not repeated measures DO NOT USE.
model_name <- lmer(frequency ~ group * syllable + (1 | ID), data = df_oft) #not used as variation is too small between #individual mice, i.e dropouts reduce sample size so it does not contribute significance towards the model.
#model_random <- lmer(frequency ~ syllable * group + (1 | group), data = df_oft) #random effects by group
#model_syllable_name <- lmer(frequency ~ syllable * group + (syllable | name), data = df_oft)
#model_1_syllable <- lmer(frequency ~ group * syllable + (1 | syllable), data = df_oft)

#(1 | name) model might be correct?


# Get the AIC values for each model, lower AIC = better
#AIC(model_1_syllable, model_name)
anova(model_name,model_simple) #thus, use model_name
```

```{r}
model_simple <- lm(frequency ~ group * syllable, data = df_oft) #removed repeated measures random variance, still works
summary(model_simple)
```

```{r}
model_var <- lmer(frequency ~ group * syllable, 
                 random = ~1 | ID, 
                 weights = varIdent(form = ~1 | syllable),
                 data = df_oft)
```


```{r}
model_oft <- lmer(frequency ~ group * syllable + (1 | ID), data = df_oft)
summary(model_oft)

```


```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - violates
qqnorm(resid(model_oft))
qqline(resid(model_oft))
# non-normal, thus, when calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
resid_oft <- resid(model_oft)
```

```{r}
#provides quantitative values if violates normality. less than 0.05 is non-normal
shap_oft <- shapiro.test(resid_oft)
shap_oft
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - VIOLATES
plot(fitted(model_oft), resid(model_oft))
#violates it, not evenly distributed, thus, Heteroscedasticity

```



```{r}
#Assumption 3 - confidence intervals - passes
confint(model_oft, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.

```


```{r}
# Obtain estimated marginal means
emm_oft <- emmeans(model_oft, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group
head(emm_oft)
```


```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_oft <- contrast(emm_oft, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm

summary(pairwise_oft)
```

```{r}
#this data will be used for plotting

# Convert the pairwise results into a data frame using summary
pairwise_results_oft <- summary(pairwise_oft)

# Filter significant results (p-value < 0.05)
sig_results_oft <- pairwise_results_oft[pairwise_results_oft$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_oft <- sig_results_oft %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

# Print sig_syllables to check
print(sig_syllables_oft) 

```


```{r}
# Calculate how many significant pairs there are at different thresholds
pairwise_results_oft <- summary(pairwise_oft)

# Count significant p-values at different thresholds
sig_counts <- list(
  p_05 = sum(pairwise_results_oft$p.value < 0.05, na.rm = TRUE),
  p_01 = sum(pairwise_results_oft$p.value < 0.01, na.rm = TRUE),
  p_001 = sum(pairwise_results_oft$p.value < 0.001, na.rm = TRUE),
  total_under_05 = sum(pairwise_results_oft$p.value < 0.05, na.rm = TRUE)  # Count all p-values < 0.05
)

# Print the counts
cat("Number of significant comparisons:\n")
cat("p < 0.05:", sig_counts$p_05, "\n")
cat("p < 0.01:", sig_counts$p_01, "\n")
cat("p < 0.001:", sig_counts$p_001, "\n")
cat("Total number of p-values at any <0.05:", sig_counts$total_under_05, "\n")  # Print total number of p-values < 0.05

# To get the specific contrasts with significant differences (p < 0.05)
sig_contrasts <- pairwise_results_oft[pairwise_results_oft$p.value < 0.05, ]
print("Significant contrasts with p < 0.05:")
print(sig_contrasts)

# Optionally, you can filter by different p-value thresholds
sig_by_01 <- pairwise_results_oft[pairwise_results_oft$p.value < 0.01, ]
sig_by_001 <- pairwise_results_oft[pairwise_results_oft$p.value < 0.001, ]

# Print significant results by stricter thresholds
cat("\nSignificant contrasts with p < 0.01:\n")
print(sig_by_01)
cat("\nSignificant contrasts with p < 0.001:\n")
print(sig_by_001)

# summary Count significant comparisons by groups (filtering by p-value < 0.05)
cat("\nSignificant comparisons by contrast type:\n")
if("contrast" %in% colnames(pairwise_results_oft)) {
  # Count by contrast type (e.g., specific group comparisons)
  sig_by_contrast <- table(pairwise_results_oft$contrast[pairwise_results_oft$p.value < 0.05])
  print(sig_by_contrast)
}
```


```{r}
#for ggplot below
syllable_labels_oft <- c(
  "0" = "0 (rear_supported)", 
  "1" = "1 (sniff_stationary)", 
  "2" = "2 (sniff_locomotion)", 
  "3" = "3 (stand-still)", 
  "4" = "4 (turn_left_sharp)", 
  "5" = "5 (thigmotaxis_right)", 
  "6" = "6 (turn_right_sharp)", 
  "7" = "7 (rear_supported_left_traverse)", 
  "8" = "8 (thigmotaxis_left)", 
  "9" = "9 (head_retract_right)", 
  "10" = "10 (turn_left_moderate)", 
  "11" = "11 (sniff_up)", 
  "12" = "12 (rear_support_right_multiple)", 
  "13" = "13 (rear_support_left_multiple)", 
  "14" = "14 (rear_supported_right_traverse)", 
  "15" = "15 (turn_left_wide)", 
  "16" = "16 (turn_right_moderate)", 
  "17" = "17 (acceleration_right)", 
  "18" = "18 (acceleration_left)", 
  "19" = "19 (slide)", 
  "20" = "20 (turn_right_wide)", 
  "21" = "21 (groom_sit)", 
  "22" = "22 (rear_support_lean)", 
  "23" = "23 (thigmotaxsis_head_tilt)", 
  "24" = "24 (acceleration_forward)", 
  "25" = "25 (hunch_sniff)", 
  "26" = "26 (head_retract_left)", 
  "27" = "27 (groom_curl)"
)
```


```{r}

# Calculate means by syllable and group
oft_means <- df_oft %>%
  group_by(syllable, group) %>%
  summarize(
    mean_freq_oft = mean(frequency, na.rm = TRUE),
    se_oft = sd(frequency, na.rm = TRUE)/sqrt(n())
  )

# Create the plot
plot_oft <- ggplot(oft_means, aes(x = syllable, y = mean_freq_oft, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = mean_freq_oft - se_oft, ymax = mean_freq_oft + se_oft), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0))
  )
# Add significance asterisks
plot_oft <- plot_oft + geom_text(
  data = sig_syllables_oft,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_oft
#ggsave("oft_graph.png", plot = plot_oft, width = 10, height = 6) #makes spaces visible

```
#OFT_relative_control

```{r}

# Calculate means by syllable and group
oft_means <- df_oft %>%
  group_by(syllable, group) %>%
  summarize(
    mean_freq_oft = mean(frequency, na.rm = TRUE),
    se_oft = sd(frequency, na.rm = TRUE)/sqrt(n())
  )


```


```{r}
# Step 1: Calculate mean for control group
control_means <- oft_means %>%
  filter(group == "control") %>%
  select(syllable, control_mean_freq_oft = mean_freq_oft)
```

```{r}
# Step 2: Join the control mean to the main dataset and calculate the relative frequency
oft_means_relative <- oft_means %>%
  left_join(control_means, by = "syllable") %>%  # Join control means
  mutate(mean_freq_relative = mean_freq_oft - control_mean_freq_oft)
print(oft_means_relative)
```



```{r}
# Create the plot with relative values
plot_oft_2 <- ggplot(oft_means_relative, aes(x = syllable, y = mean_freq_relative, color = group, group = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_freq_relative - se_oft, ymax = mean_freq_relative + se_oft), width = 0.2) +
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency (relative to control)",
    color = NULL
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +  # Add baseline at 0
  ylim(-0.1, 0.2) +  # Adjust if needed depending on your data
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0))
  )
plot_oft_2
#ggsave("oft_graph_2.png", plot = plot_oft_2, width = 10, height = 6) #makes spaces visible
```
# OFT_ordered_control
```{r}
# Get syllables ordered by mean frequency in control group
syllable_order <- df_oft %>% #syllable_order is the function
  filter(group == "control") %>%
  group_by(syllable) %>%
  summarize(mean_freq = mean(frequency, na.rm = TRUE)) %>%
  arrange(desc(mean_freq)) %>% #computed mean frequency sorted from most to least
  pull(syllable) # Extract just the ordered syllable names, this controls x-axis of plot
```

```{r}
df_oft <- df_oft %>%
  mutate(syllable = factor(syllable, levels = syllable_order))
```
 
```{r}
oft_means <- df_oft %>% #recalculate mean and standard error
  group_by(syllable, group) %>%
  summarize(
    mean_freq_oft = mean(frequency, na.rm = TRUE),
    se_oft = sd(frequency, na.rm = TRUE)/sqrt(n()),
    .groups = "drop"
  )
```

```{r}
plot_oft_3 <- ggplot(oft_means, aes(x = syllable, y = mean_freq_oft, color = group, group = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_freq_oft - se_oft, ymax = mean_freq_oft + se_oft), width = 0.2) +
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft[syllable_order]) +  # Optional: reorder labels if needed
  labs(
    x = "Syllables (Ordered by Control Frequency)",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0))
  )
plot_oft_3
#ggsave("oft_graph_3.png", plot = plot_oft_3, width = 10, height = 6) #makes spaces visible
```


# NOR_model

```{r}
#load results file and make sure headings and levels are established

df_nor <- read.csv("new_moseq_NOR_stats.csv", header=TRUE)
df_nor$syllable <- factor(df_nor$syllable)  # Convert to categorical
df_nor$group <- factor(df_nor$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
df_nor$ID <- factor(df_nor$ID)

```

```{r}
#model_simple <- lm(frequency ~ group * syllable, data = df_oft) #removed repeated measures random variance, still works
#summary(model_simple)

#or

model_nor <- lmer(frequency ~ group * syllable + (1 | ID), data = df_nor)
summary(model_nor)
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_nor))
qqline(resid(model_nor))
#probs a lil' bit non-normal, thus, whe calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
hist(resid(model_nor)) 
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_nor), resid(model_nor))
#violates it, not evenly distributed, thus, Heteroscedasticity
```

```{r}
#Assumption 3 - confidence intervals - passes
confint(model_nor, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.

```

```{r}
# Obtain estimated marginal means
emm_nor <- emmeans(model_nor, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group (groupwise effects for each syllable)
head(emm_nor)
```


```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_nor <- contrast(emm_nor, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm

summary(pairwise_nor)
```

```{r}
#this data will be used for plotting

# Convert the pairwise results into a data frame using summary
pairwise_results_nor <- summary(pairwise_nor)

# Filter significant results (p-value < 0.05)
sig_results_nor <- pairwise_results_nor[pairwise_results_nor$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_nor <- sig_results_nor %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

# Print sig_syllables to check
print(sig_syllables_nor)
```

```{r}
#for ggplot below
syllable_labels_nor <-c(
  "0" = "0 (rear_supported)",
  "1" = "1 (sniff)",
  "2" = "2 (stand-still)",
  "3" = "3 (turn_left_moderate)",
  "4" = "4 (turn_right_moderate)",
  "5" = "5 (sniff_object)",
  "6" = "6 (turn_right_sharp)",
  "7" = "7 (turn_left_sharp)",
  "8" = "8 (acceleration_left)",
  "9" = "9 (rear_supported_left_traverse)",
  "10" = "10 (acceleration_right)",
  "11" = "11 (locomotion_sniff)",
  "12" = "12 (thigmotaxsis_right)",
  "13" = "13 (rear_supported_multiple)",
  "14" = "14 (rear_supported_right_traverse)",
  "15" = "15 (sniff_up)",
  "16" = "16 (spin_left)",
  "17" = "17 (sniff_down)",
  "18" = "18 (hunch)",
  "19" = "19 (thigmotaxsis_left)",
  "20" = "20 (groom_jump_object)",
  "21" = "21 (groom_curl)",
  "22" = "22 (thigmotaxsis_walk)"
)

```



```{r}
# Calculate means by syllable and group
nor_means <- df_nor %>%
  group_by(syllable, group) %>%
  summarize(
    mean_freq_nor = mean(frequency, na.rm = TRUE),
    se_nor = sd(frequency, na.rm = TRUE)/sqrt(n())
  )

# Create the plot
plot_nor <- ggplot(nor_means, aes(x = syllable, y = mean_freq_nor, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = mean_freq_nor - se_nor, ymax = mean_freq_nor + se_nor), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_nor) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_nor <- plot_nor + geom_text(
  data = sig_syllables_nor,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_nor
#ggsave("nor_graph.png", plot = plot_nor, width = 10, height = 6) #makes spaces visible

```

# EPM_model

```{r}
#load results file and make sure headings and levels are established

df_epm <- read.csv("new_moseq_EPM_stats.csv", header=TRUE)
df_epm$syllable <- factor(df_epm$syllable)  # Convert to categorical
df_epm$group <- factor(df_epm$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
df_epm$ID <- factor(df_epm$ID)

```

```{r}
model_epm <- lmer(frequency ~ group * syllable + (1 | ID), data = df_epm)
summary(model_epm)
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_epm))
qqline(resid(model_epm))
#probs a lil' bit non-normal, thus, whe calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_epm), resid(model_epm))
#violates it, not evenly distributed, thus, Heteroscedasticity
```

```{r}
hist(resid(model_epm)) 
```

```{r}
#Assumption 3 - confidence intervals - passes
confint(model_epm, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.

```

```{r}
# Obtain estimated marginal means
emm_epm <- emmeans(model_epm, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group (groupwise effects for each syllable)
head(emm_epm)
```


```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_epm <- contrast(emm_epm, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm

summary(pairwise_epm)
```


```{r}
#this data will be used for plotting

# Convert the pairwise results into a data frame using summary
pairwise_results_epm <- summary(pairwise_epm)

# Filter significant results (p-value < 0.05)
sig_results_epm <- pairwise_results_epm[pairwise_results_epm$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_epm <- sig_results_epm %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

# Print sig_syllables to check
print(sig_syllables_epm)
```
```{r}
syllable_labels_epm <- c(
  "0" = "0 (stationary_sniff)", 
  "1" = "1 (stationary_tilt)", 
  "2" = "2 (sniff_right)", 
  "3" = "3 (groom_hunch)", 
  "4" = "4 (sniff_left)", 
  "5" = "5 (turn_left_sharp)", 
  "6" = "6 (sniff_forwards)", 
  "7" = "7 (rear_supported/groom)", 
  "8" = "8 (locomotion_brief)", 
  "9" = "9 (rear_supported)", 
  "10" = "10 (locomotion_tilt)", 
  "11" = "11 (accelerate_forward)", 
  "12" = "12 (sniff_junction)", 
  "13" = "13 (rear_supported_twist)", 
  "14" = "14 (turn_left_stationary)", 
  "15" = "15 (turn_right_stationary)", 
  "16" = "16 (rear_supported)", 
  "17" = "17 (rear_supported)"
)
```


```{r}
# Calculate means by syllable and group
epm_means <- df_epm %>%
  group_by(syllable, group) %>%
  summarize(
    mean_freq_epm = mean(frequency, na.rm = TRUE),
    se_epm = sd(frequency, na.rm = TRUE)/sqrt(n())
  )

# Create the plot
plot_epm <- ggplot(epm_means, aes(x = syllable, y = mean_freq_epm, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = mean_freq_epm - se_epm, ymax = mean_freq_epm + se_epm), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_epm) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_epm <- plot_epm + geom_text(
  data = sig_syllables_epm,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_epm
#ggsave("epm_graph.png", plot = plot_epm, width = 10, height = 6) #makes spaces visible
```


# 3CT_model

```{r}
#load results file and make sure headings and levels are established

df_3ct <- read.csv("new_moseq_3CT_stats.csv", header=TRUE)
df_3ct$syllable <- factor(df_3ct$syllable)  # Convert to categorical
df_3ct$group <- factor(df_3ct$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
df_3ct$ID <- factor(df_3ct$ID)

```

```{r}
model_3ct <- lmer(frequency ~ group * syllable + (1 | ID), data = df_3ct)
summary(model_3ct)
```


```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_3ct))
qqline(resid(model_3ct))
#violates
```

```{r}
hist(resid(model_3ct)) 
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_3ct), resid(model_3ct))
#violates it, not evenly distributed, thus, Heteroscedasticity
```

```{r}
#Assumption 3 - confidence intervals - passes
confint(model_3ct, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.

```

```{r}
# Obtain estimated marginal means
emm_3ct <- emmeans(model_3ct, ~ group | syllable) #groupwise effects for each syllable for frequency means
head(emm_3ct)
```

```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_3ct <- contrast(emm_3ct, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm
summary(pairwise_3ct)
```

```{r}
#this data will be used for plotting

# Convert the pairwise results into a data frame using summary
pairwise_results_3ct <- summary(pairwise_3ct)

# Filter significant results (p-value < 0.05)
sig_results_3ct <- pairwise_results_3ct[pairwise_results_3ct$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_3ct <- sig_results_3ct %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

# Print sig_syllables to check
print(sig_syllables_3ct)
```


```{r}
#for ggplot below
syllable_labels_3ct <- c(
  "0" = "0 (rear_chamber)",
  "1" = "1 (stand_still)",
  "2" = "2 (accelerate_short)",
  "3" = "3 (accelerate_arch)",
  "4" = "4 (rear_supported)",
  "5" = "5 (turn_left_sharp)",
  "6" = "6 (turn_right_sharp)",
  "7" = "7 (sniff_up)",
  "8" = "8 (accelerate_chamber)",
  "9" = "9 (turn_left_moderate)",
  "10" = "10 (turn_right_moderate)",
  "11" = "11 (sniff_locomotion)",
  "12" = "12 (sniff_arch_before)",
  "13" = "13 (sniff_arch_after)",
  "14" = "14 (accelerate_medium)",
  "15" = "15 (head_retract)",
  "16" = "16 (sniff_wall)",
  "17" = "17 (rear_supported_sporadic)",
  "18" = "18 (thigmotaxis_left)",
  "19" = "19 (thigmotaxis_chamber)",
  "20" = "20 (thigmotaxsis_divider)",
  "21" = "21 (accelerate_arch_right)",
  "22" = "22 (head_turn_left)",
  "23" = "23 (unknown)",
  "24" = "24 (unknown)",
  "25" = "25 (standstill_arch)",
  "26" = "26 (head_turn_right)",
  "27" = "27 (unknown)",
  "28" = "28 (sniff_wall)",
  "29" = "29 (look)",
  "30" = "30 (thigmotaxis_arch)",
  "31" = "31 (sniff_stationary)",
  "32" = "32 (head_dip_arch)",
  "33" = "33 (arch_angle_left)",
  "34" = "34 (arch_angle_right)",
  "35" = "35 (groom_curled)",
  "36" = "36 (unknown)",
  "37" = "37 (unknown)",
  "38" = "38 (thigmotaxis_right)"
)
```


```{r}
# Calculate means by syllable and group
means_3ct <- df_3ct %>%
  group_by(syllable, group) %>%
  summarize(
    mean_freq_3ct = mean(frequency, na.rm = TRUE),
    se_3ct = sd(frequency, na.rm = TRUE)/sqrt(n())
  )

# Create the plot
plot_3ct <- ggplot(means_3ct, aes(x = syllable, y = mean_freq_3ct, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = mean_freq_3ct - se_3ct, ymax = mean_freq_3ct + se_3ct), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_3ct) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_3ct <- plot_3ct + geom_text(
  data = sig_syllables_3ct,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_3ct
#ggsave("3ct_graph.png", plot = plot_3ct, width = 14, height = 6) #makes spaces visible
```

# 3ct_SE_model

```{r}
emm_3ct
```


```{r}
# extract results from the emm_3ct
emm_df_3ct <- as.data.frame(emm_3ct) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, asymp.LCL, asymp.UCL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
head(emm_df_3ct)
```

```{r}

# Create the plot
plot_3ct <- ggplot(emm_df_3ct, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_3ct) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_3ct <- plot_3ct + geom_text(
  data = sig_syllables_3ct,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_3ct
#ggsave("3ct_graph(SE).png", plot = plot_3ct, width = 14, height = 6) #makes spaces visible
```

#nor_SE_model

```{r}
# extract results from the emm_3ct
emm_df_nor <- as.data.frame(emm_nor) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
head(emm_df_nor)
```


```{r}

# Create the plot
plot_nor <- ggplot(emm_df_nor, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_nor) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_nor <- plot_nor + geom_text(
  data = sig_syllables_nor,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_nor
#ggsave("nor_graph(SE).png", plot = plot_nor, width = 10, height = 6) #makes spaces visible
```
#oft_SE_model

```{r}
# extract results from the emm_3ct
emm_df_oft <- as.data.frame(emm_oft) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_oft
```

```{r}
# Create the plot
plot_oft <- ggplot(emm_df_oft, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_oft <- plot_oft + geom_text(
  data = sig_syllables_oft,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_oft
#ggsave("oft_graph(SE).png", plot = plot_oft, width = 10, height = 6) #makes spaces visible
```

```{r}
# extract results from the emm_3ct
emm_df_oft <- as.data.frame(emm_oft) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_oft
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order <- emm_df_oft %>%
  filter(group == "control") %>%
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_oft <- emm_df_oft %>%
  mutate(syllable = factor(syllable, levels = syllable_order))
emm_df_oft
```
```{r}
#this data will be used for plotting
# Apply the same syllable ordering as in emm_df_oft
# Convert the pairwise results into a data frame using summary

pairwise_results_oft <- summary(pairwise_oft)

# Filter significant results (p-value < 0.05)
sig_results_oft <- pairwise_results_oft[pairwise_results_oft$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_oft <- sig_results_oft %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

sig_syllables_oft <- sig_syllables_oft %>%
  mutate(syllable = factor(syllable, levels = levels(emm_df_oft$syllable)))
# Print sig_syllables to check
print(sig_syllables_oft)
```
```{r}
#check if factor ordering is same
levels(emm_df_oft$syllable)
levels(sig_syllables_oft$syllable)
```


```{r}
# Create the plot
plot_oft <- ggplot(emm_df_oft, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  # Labels for axes and legend
  labs(
    x = "Syllables (Order by Control Frequency)",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_oft <- plot_oft + geom_text(
  data = sig_syllables_oft,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_oft
#ggsave("oft_graph(SE_order).png", plot = plot_oft, width = 10, height = 6) #makes spaces visible
```


#epm_SE_model

```{r}
# extract results from the emm_3ct
emm_df_epm <- as.data.frame(emm_epm) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_epm
```


```{r}

# Create the plot
plot_epm <- ggplot(emm_df_epm, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_epm) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_epm <- plot_epm + geom_text(
  data = sig_syllables_epm,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "control - post_w2" ~ 0.24,
        contrast == "post_w1 - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_epm
ggsave("epm_graph(SE).png", plot = plot_epm, width = 10, height = 6) #makes spaces visible
```

#OFT_ordered_SE

```{r}
#load results file and make sure headings and levels are established

df_oft <- read.csv("NEW_new_moseq_OFT_stats.csv", header=TRUE)
df_oft$syllable <- factor(df_oft$syllable)  # Convert to categorical
df_oft$group <- factor(df_oft$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
#cool fact, code above sets "control" as baseline value as it comes first
df_oft$ID <- factor(df_oft$ID)

```

```{r}
str(df_oft)
```


```{r}
model_oft <- lmer(frequency ~ group * syllable + (1 | ID), data = df_oft)
summary(model_oft)
```

```{r}
# Get the AIC values for each model, lower AIC = better
#AIC(model_1_syllable, model_name)
#anova(model_name,model_simple) #thus, use model_name
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_oft))
qqline(resid(model_oft))
#probs a lil' bit non-normal, thus, whe calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_oft), resid(model_oft))
#violates it, not evenly distributed, thus, Heteroscedasticity
```

```{r}
effect_oft = eta_squared(model_oft)
print(effect_oft)
#0 to 1, 1 being factor has huge effect on the frequency
```


```{r}
#Assumption 3 - confidence intervals - passes
confint(model_oft, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.
#DF analysis uses kenward-roger adjustment to take into account small and uneven sample size
#boot is for violations of assumptions
```

```{r}
# Obtain estimated marginal means
emm_oft <- emmeans(model_oft, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group
head(emm_oft)
#kenward-roger is for unequal sample size
```

```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_oft <- contrast(emm_oft, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm, tukey, dunnett, sidak [tukey, holm]
#kenward-roger is for unequal sample size
#holm seems good for our data, check with ilary
summary(pairwise_oft)
```

```{r}
#for ggplot below
syllable_labels_oft <- c(
  "0" = "0 (sniff_locomotion)",
  "1" = "1 (rear_supported)",
  "2" = "2 (stand-still)",
  "3" = "3 (turn_right_sharp)",
  "4" = "4 (turn_left_sharp)",
  "5" = "5 (locomotion_sniff_right)",
  "6" = "6 (rear_supported_left)",
  "7" = "7 (locomotion_sniff_left)",
  "8" = "8 (head_dip_left)",
  "9" = "9 (turn_sniff_left)",
  "10" = "10 (acceleration_left)",
  "11" = "11 (turn_sniff_right)",
  "12" = "12 (rear_supported_right_multiple)",
  "13" = "13 (thigmotaxis_rear)",
  "14" = "14 (rear_supported_right_locomotion)",
  "15" = "15 (acceleration_right)",
  "16" = "16 (locomotion_straight)",
  "17" = "17 (rear_supported_left_partial)",
  "18" = "18 (rear_supported_left_multiple)",
  "19" = "19 (thigomtaxis_locomotion)",
  "20" = "20 (rear_supported/unsupported)",
  "21" = "21 (head_retract)",
  "22" = "22 (head_dip_right)",
  "23" = "23 (look_up)",
  "24" = "24 (groom/rear)",
  "25" = "25 (rear_supported_right)",
  "26" = "26 (sniff_up)",
  "27" = "27 (rear_supported_left_locomotion)",
  "28" = "28 (back_step)"
)
```

```{r}
# start to order by control frequency

#extract results from the emmeans
emm_df_oft <- as.data.frame(emm_oft) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_oft 
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order_oft <- emm_df_oft %>%
  filter(group == "control") %>%
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_oft <- emm_df_oft %>%
  mutate(syllable = factor(syllable, levels = syllable_order_oft))
emm_df_oft
```

```{r}
# TESTING THE CONFIDENCE INTERVALS INSTEAD OF SE TO CHECK SYLLABLE 0
plot_oft_test <- ggplot(emm_df_oft, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  #geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - lower.CL, ymax = emmean + upper.CL), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  # Labels for axes and legend
  labs(
    x = "Syllables",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 18),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_oft <- plot_oft + geom_text(
  data = sig_syllables_oft,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "post_w1 - post_w2" ~ 0.24,
        contrast == "control - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_oft_test
#ggsave("oft_graph(test_CL).png", plot = plot_oft_test, width = 11, height = 6) #makes spaces visible
```



```{r}
#this data will be used for plotting
# Apply the same syllable ordering as in emm_df
# Convert the pairwise results into a data frame using summary

pairwise_results_oft <- summary(pairwise_oft)

# Filter significant results (p-value < 0.05)
sig_results_oft <- pairwise_results_oft[pairwise_results_oft$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_oft <- sig_results_oft %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

sig_syllables_oft <- sig_syllables_oft %>%
  mutate(syllable = factor(syllable, levels = levels(emm_df_oft$syllable)))
# Print sig_syllables to check
print(sig_syllables_oft)
```

```{r}
#check if factor ordering is same
levels(emm_df_oft$syllable)
levels(sig_syllables_oft$syllable)
```

```{r}
# Create the plot
plot_oft <- ggplot(emm_df_oft, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  #geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  # Labels for axes and legend
  labs(
    x = "Syllables",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 18),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_oft <- plot_oft + geom_text(
  data = sig_syllables_oft,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "post_w1 - post_w2" ~ 0.24,
        contrast == "control - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_oft
#ggsave("oft_graph(FINAL).png", plot = plot_oft, width = 11, height = 6) #makes spaces visible
```

#NOR_ordered_SE

```{r}
#load results file and make sure headings and levels are established

df_nor <- read.csv("NEW_new_moseq_NOR_stats.csv", header=TRUE)
df_nor$syllable <- factor(df_nor$syllable)  # Convert to categorical
df_nor$group <- factor(df_nor$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
#cool fact, code above sets "control" as baseline value as it comes first
df_nor$ID <- factor(df_nor$ID)

```

```{r}
str(df_nor)
```

```{r}
model_nor <- lmer(frequency ~ group * syllable + (1 | ID), data = df_nor)
summary(model_nor)
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_nor))
qqline(resid(model_nor))
#probs a lil' bit non-normal, thus, whe calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_nor), resid(model_nor))
#violates it, not evenly distributed, thus, Heteroscedasticity

```

```{r}
#Assumption 3 - confidence intervals - passes
confint(model_nor, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.
#DF analysis uses kenward-roger adjustment to take into account small and uneven sample size
#boot is for violations of assumptions
```

```{r}
# Obtain estimated marginal means
emm_nor <- emmeans(model_nor, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group
head(emm_nor)
#kenward-roger is for unequal sample size
```

```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_nor <- contrast(emm_nor, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm, tukey
#kenward-roger is for unequal sample size

summary(pairwise_nor)
```

```{r}
#for ggplot below
syllable_labels_nor <-c(
  "0" = "0 (sniff_stationary)",
  "1" = "1 (stand-still)",
  "2" = "2 (turn_right)",
  "3" = "3 (look_up_right)",
  "4" = "4 (turn_left)",
  "5" = "5 (locomotion_right)",
  "6" = "6 (rear_supported_left_traverse)",
  "7" = "7 (turn_left_diagonal)",
  "8" = "8 (sniff_object)",
  "9" = "9 (turn_sniff_left)",
  "10" = "10 (turn_left_moderate)",
  "11" = "11 (rear_supported_left_locomotion)",
  "12" = "12 (sniff_locomotion)",
  "13" = "13 (rear_supported_right_locomotion)",
  "14" = "14 (acceleration_left)",
  "15" = "15 (hunched_groom/stationary_sniff)",
  "16" = "16 (look_up)",
  "17" = "17 (head_turn_right)",
  "18" = "18 (rear_supported_right_traverse)",
  "19" = "19 (rear_supported_right_acceleration)",
  "20" = "20 (head_dip)",
  "21" = "21 (rear_supported_left_acceleration)",
  "22" = "22 (groom_curled/supported_rearing)",
  "23" = "23 (accelerate_head_retract)",
  "24" = "24 (rear_supported_left_acceleration)",
  "25" = "25 (groom_corner/climb_object)"
)
```

```{r}
# start to order by control frequency

#extract results from the emmeans
emm_df_nor <- as.data.frame(emm_nor) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_nor
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order_nor <- emm_df_nor %>%
  filter(group == "control") %>%
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_nor <- emm_df_nor %>%
  mutate(syllable = factor(syllable, levels = syllable_order_nor))
emm_df_nor
```

```{r}
#this data will be used for plotting
# Apply the same syllable ordering as in emm_df
# Convert the pairwise results into a data frame using summary

pairwise_results_nor <- summary(pairwise_nor)

# Filter significant results (p-value < 0.05)
sig_results_nor <- pairwise_results_nor[pairwise_results_nor$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_nor <- sig_results_nor %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

sig_syllables_nor <- sig_syllables_nor %>%
  mutate(syllable = factor(syllable, levels = levels(emm_df_nor$syllable)))
# Print sig_syllables to check
print(sig_syllables_nor)
```

```{r}
#check if factor ordering is same
levels(emm_df_nor$syllable)
levels(sig_syllables_nor$syllable)
```

```{r}
# Create the plot
plot_nor <- ggplot(emm_df_nor, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  #geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_nor) +
  # Labels for axes and legend
  labs(
    x = "Syllables",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.4) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 18),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_nor <- plot_nor + geom_text(
  data = sig_syllables_nor,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.38,
        contrast == "post_w1 - post_w2" ~ 0.34,
        contrast == "control - post_w2" ~ 0.30,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_nor
#ggsave("nor_graph(FINAL).png", plot = plot_nor, width = 10, height = 6) #makes spaces visible
```

#EPM_ordered_SE

```{r}
#load results file and make sure headings and levels are established

df_epm <- read.csv("new_moseq_EPM_stats.csv", header=TRUE)
df_epm$syllable <- factor(df_epm$syllable)  # Convert to categorical
df_epm$group <- factor(df_epm$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
#cool fact, code above sets "control" as baseline value as it comes first
df_epm$ID <- factor(df_epm$ID)

```

```{r}
str(df_epm)
```

```{r}
model_epm <- lmer(frequency ~ group * syllable + (1 | ID), data = df_epm)
summary(model_epm)
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_epm))
qqline(resid(model_epm))
#probs a lil' bit non-normal, thus, whe calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_epm), resid(model_epm))
#violates it, not evenly distributed, thus, Heteroscedasticity
```

```{r}
#Assumption 3 - confidence intervals - passes
confint(model_epm, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.
#DF analysis uses kenward-roger adjustment to take into account small and uneven sample size
#boot is for violations of assumptions
```

```{r}
# Obtain estimated marginal means
emm_epm <- emmeans(model_epm, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group
head(emm_epm)
#kenward-roger is for unequal sample size
```

```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_epm <- contrast(emm_epm, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm, tukey
#kenward-roger is for unequal sample size

summary(pairwise_epm)
```

```{r}
#for ggplot below
syllable_labels_epm <- c(
  "0" = "0 (sniff)",
  "1" = "1 (stand-still)",
  "2" = "2 (sniff_left)",
  "3" = "3 (sniff_right)",
  "4" = "4 (rear_supported_twist)",
  "5" = "5 (stretch-attend)",
  "6" = "6 (sniff_up)",
  "7" = "7 (head_tilt)",
  "8" = "8 (sniff_locomotion)",
  "9" = "9 (locomotion_brief)",
  "10" = "10 (groom/rear_supported)",
  "11" = "11 (rear_supported)",
  "12" = "12 (turn_stationary_fast)",
  "13" = "13 (sniff_corner)",
  "14" = "14 (stretch-attend_angle)",
  "15" = "15 (turn_stationary_slow)",
  "16" = "16 (stretch-attend_left/right)",
  "17" = "17 (rear_supported_high)",
  "18" = "18 (head_dip)",
  "19" = "19 (sniff_diagonal)",
  "20" = "20 (turn_stationary_right)"
)
```

```{r}
# start to order by control frequency

#extract results from the emmeans
emm_df_epm <- as.data.frame(emm_epm) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_epm
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order_epm <- emm_df_epm %>%
  filter(group == "control") %>%
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_epm <- emm_df_epm %>%
  mutate(syllable = factor(syllable, levels = syllable_order_epm))
emm_df_epm
```

```{r}
#this data will be used for plotting
# Apply the same syllable ordering as in emm_df
# Convert the pairwise results into a data frame using summary

pairwise_results_epm <- summary(pairwise_epm)

# Filter significant results (p-value < 0.05)
sig_results_epm <- pairwise_results_epm[pairwise_results_epm$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_epm <- sig_results_epm %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

sig_syllables_epm <- sig_syllables_epm %>%
  mutate(syllable = factor(syllable, levels = levels(emm_df_epm$syllable)))
# Print sig_syllables to check
print(sig_syllables_epm)
```

```{r}
#check if factor ordering is same
levels(emm_df_epm$syllable)
levels(sig_syllables_epm$syllable)
```

```{r}
# Create the plot
plot_epm <- ggplot(emm_df_epm, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  #geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_epm) +
  # Labels for axes and legend
  labs(
    x = "Syllables",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 18),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_epm <- plot_epm + geom_text(
  data = sig_syllables_epm,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.30,
        contrast == "post_w1 - post_w2" ~ 0.26,
        contrast == "control - post_w2" ~ 0.22,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_epm
#ggsave("epm_graph(FINAL).png", plot = plot_epm, width = 10, height = 6) #makes spaces visible
```

#3CT_ordered_SE

```{r}
#load results file and make sure headings and levels are established

df_3ct <- read.csv("new_moseq_3CT_stats.csv", header=TRUE)
df_3ct$syllable <- factor(df_3ct$syllable)  # Convert to categorical
df_3ct$group <- factor(df_3ct$group, levels = c("control", "post_w1", "post_w2")) #factor level categorical
#cool fact, code above sets "control" as baseline value as it comes first
df_3ct$ID <- factor(df_3ct$ID)

```

```{r}
str(df_3ct)
```

```{r}
model_3ct <- lmer(frequency ~ group * syllable + (1 | ID), data = df_3ct)
summary(model_3ct)
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - passes
qqnorm(resid(model_3ct))
qqline(resid(model_3ct))
#probs a lil' bit non-normal, thus, whe calculating confidence intervals, used "boot" method which assumes non-normality
```

```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - passes
plot(fitted(model_3ct), resid(model_3ct))
#violates it, not evenly distributed, thus, Heteroscedasticity
```

```{r}
#Assumption 3 - confidence intervals - passes
confint(model_3ct, method = "boot")
#if CI includes zero between 2.5% and 97.5% then that effect is not statistically significant.
#DF analysis uses kenward-roger adjustment to take into account small and uneven sample size
#boot is for violations of assumptions
```

```{r}
# Obtain estimated marginal means
#emm_3ct <- emmeans(model_3ct, ~ group | syllable, lmerTest.limit = 4219)
emm_3ct <- emmeans(model_3ct, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group
head(emm_3ct)
#kenward-roger is for unequal sample size
```

```{r}
#pairwise comparison with tukey, due to lots of syllable comparisons (more tests)
pairwise_3ct <- contrast(emm_3ct, method = "pairwise", adjust = "tukey") #bonferroni, Satterthwaite, Kenward-Roger, holm, tukey
#kenward-roger is for unequal sample size

summary(pairwise_3ct)
```


```{r}
#for ggplot below
syllable_labels_3ct <- c(
  "0" = "0 (sniff_right)",
  "1" = "1 (sniff_stationary)",
  "2" = "2 (acceleration_arch_after)",
  "3" = "3 (diagonal_left)",
  "4" = "4 (sniff_left)",
  "5" = "5 (turn_right_moderate)",
  "6" = "6 (locomotion_brief)",
  "7" = "7 (turn_left_moderate)",
  "8" = "8 (locomotion_sniff)",
  "9" = "9 (locomotion_head_turn)",
  "10" = "10 (accelerate_brief)",
  "11" = "11 (locomotion_arch_before)",
  "12" = "12 (locomotion_arch_brief)",
  "13" = "13 (stand-still_brief)",
  "14" = "14 (locomotion_stop_sniff)",
  "15" = "15 (locomotion_arch_left)",
  "16" = "16 (rear_unsupported/interact_arch)",
  "17" = "17 (rear_unsupported/supported)",
  "18" = "18 (alongside_divider)",
  "19" = "19 (locomotion_arch_long)",
  "20" = "20 (turn_divider)",
  "21" = "21 (rear_supported_right)",
  "22" = "22 (rear_supported/groom/sniff_arch)",
  "23" = "23 (turn_sharp_right)",
  "24" = "24 (locomotion_steps)",
  "25" = "25 (sniff_up_left)",
  "26" = "26 (rear_supported_chamber)",
  "27" = "27 (rear_unsupported/approach_divider)",
  "28" = "28 (acceleration_arch_brief)",
  "29" = "29 (rear_supported_left)",
  "30" = "30 (locomotion_arch_angle_right)",
  "31" = "31 (sniff_arch)",
  "32" = "32 (approach_divider)",
  "33" = "33 (mixed)",
  "34" = "34 (interact_divider)",
  "35" = "35 (interact_arch)",
  "36" = "36 (climb/jump)",
  "37" = "37 (locomotion_arch_left_angle)",
  "38" = "38 (stand-still_long)",
  "39" = "39 (sniff_corners_left)",
  "40" = "40 (arch_halt)",
  "41" = "41 (sniff_chamber_corner)",
  "42" = "42 (turn_sharp_left)",
  "43" = "43 (mixed)"
)
```

```{r}
# start to order by control frequency

#extract results from the emmeans
emm_df_3ct <- as.data.frame(emm_3ct) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, asymp.LCL, asymp.UCL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_3ct
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order_3ct <- emm_df_3ct %>%
  filter(group == "control") %>%
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_3ct <- emm_df_3ct %>%
  mutate(syllable = factor(syllable, levels = syllable_order_3ct))
emm_df_3ct
```

```{r}
#this data will be used for plotting
# Apply the same syllable ordering as in emm_df
# Convert the pairwise results into a data frame using summary

pairwise_results_3ct <- summary(pairwise_3ct)

# Filter significant results (p-value < 0.05)
sig_results_3ct <- pairwise_results_3ct[pairwise_results_3ct$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_3ct <- sig_results_3ct %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

sig_syllables_3ct <- sig_syllables_3ct %>%
  mutate(syllable = factor(syllable, levels = levels(emm_df_3ct$syllable)))
# Print sig_syllables to check
print(sig_syllables_3ct)
```

```{r}
#check if factor ordering is same
levels(emm_df_3ct$syllable)
levels(sig_syllables_3ct$syllable)
```

```{r}
# Create the plot
plot_3ct <- ggplot(emm_df_3ct, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
  #geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_3ct) +
  # Labels for axes and legend
  labs(
    x = "Syllables",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 18),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_3ct <- plot_3ct + geom_text(
  data = sig_syllables_3ct,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "post_w1 - post_w2" ~ 0.24,
        contrast == "control - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_3ct
#ggsave("3ct_graph(FINAL).png", plot = plot_3ct, width = 15, height = 6) #makes spaces visible
```

#geelm model OFT

```{r}
#geelm model
#Generalized estimating equations Generalised Linear Model
#testing data with geeglm for non-normal data and repeated measures
#it doesn't model random effects, so its best when you're interested in average population trends rather than individual subject trajectories
#models populations average rather than individual differences like lmer with random intercepts.
#it clusters ID together
#HOWEVER, it is not ideal for for missing data
##FURTHERMORE EXPLANATION ON MISSING DATA. Since the mice are sacrificed because their symptoms get too severe, and those symptoms relate directly to the outcome youre studying (severity of disease), the missingness depends on the unobserved outcome itself (because after sacrifice, you no longer get data).
#Thus, this model is not compatible.
#This is a classic example of Missing Not At Random (MNAR)  the missing data is linked to the very thing you're measuring (severity), which you cant fully observe after sacrifice.
model_gee_oft <- geeglm(frequency ~ group * syllable, id = ID, data = df_oft, family = gaussian,corstr = "exchangeable")         # Can be "independence", "ar1", "unstructured"
summary(model_gee_oft)
```

```{r}
gee_emm_oft <- emmeans(model_gee_oft, ~ group * syllable)
gee_emm_oft
```

```{r}
gee_contrast_oft <- contrast(gee_emm_oft, method = "pairwise", by = "syllable", adjust = "tukey")
gee_contrast_oft
```

```{r}
#this data will be used for plotting

# Filter significant results (p-value < 0.05)
gee_contrast_oft_tuk <- gee_contrast_oft_tuk[gee_contrast_oft_tuk$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_oft_gee <- gee_contrast_oft_tuk %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

#make factor levels same for a-axis
sig_syllables_oft_gee <- sig_syllables_oft_gee %>%
  mutate(syllable = factor(syllable, levels = syllable_order_oft_gee))

# Print sig_syllables to check
print(sig_syllables_oft_gee)
```

```{r}
# start to order by control frequency
#turn into dataframe
#extract results from the emmeans
emm_df_oft_gee <- as.data.frame(gee_emm_oft) %>%
  # Select the relevant columns
  select(group, syllable, emmean, SE, df, lower.CL, upper.CL) %>%
  mutate(
    syllable = as.factor(syllable),  # Ensure syllable is a factor
    group = factor(group, levels = c("control", "post_w1", "post_w2")) # Factor level for plotting
  )
# View the resulting formatted data
emm_df_oft_gee
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order_oft_gee <- emm_df_oft_gee %>%
  filter(group == "control") %>% 
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_oft_gee <- emm_df_oft_gee %>%
  mutate(syllable = factor(syllable, levels = syllable_order_oft_gee))
emm_df_oft_gee

```

```{r}
#check if factor ordering is same
levels(emm_df_oft_gee$syllable)
levels(sig_syllables_oft_gee$syllable)
```

```{r}
# Create the plot
plot_oft_gee <- ggplot(emm_df_oft_gee, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
#  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_oft) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_oft_gee <- plot_oft_gee + geom_text(
  data = sig_syllables_oft_gee,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "post_w1 - post_w2" ~ 0.24,
        contrast == "control - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_oft_gee
#ggsave("oft_graph(SE)_gee.png", plot = plot_oft_gee, width = 10, height = 6) #makes spaces visible
```
##assumptions_OFT

```{r}
# Extract Pearson residuals
residuals_gee <- residuals(model_gee_oft, type = "pearson")

# Plot residuals vs fitted values
plot(fitted(model_gee_oft), residuals_gee)
abline(h = 0, col = "red")
```


#geelm model NOR


#geelm model EPM


#geelm model 3CT

```{r}
model_gee_3ct <- geeglm(frequency ~ group * syllable, id = ID, data = df_3ct, family = gaussian,corstr = "exchangeable")         # Can be "independence", "ar1", "unstructured"
summary(model_gee_3ct)
```

```{r}
gee_emm_3ct <- emmeans(model_gee_3ct, ~ group * syllable)
gee_emm_3ct
```

```{r}
gee_contrast_3ct <- contrast(gee_emm_3ct, method = "pairwise", by = "syllable", adjust = "tukey")
summary(gee_contrast_3ct)
```

```{r}
#this data will be used for plotting

# Convert the pairwise results into a data frame using summary
pairwise_results_3ct_gee <- summary(gee_contrast_3ct)

# Filter significant results (p-value < 0.05)
sig_results_3ct_gee <- pairwise_results_3ct_gee[pairwise_results_3ct_gee$p.value < 0.05, ]

# Create a data frame for significant syllables, labels, and contrast groups
sig_syllables_3ct_gee <- sig_results_3ct_gee %>%
  mutate(label = ifelse(p.value < 0.001, "***", 
                       ifelse(p.value < 0.01, "**", 
                              ifelse(p.value < 0.05, "*", "ns")))) %>%
  select(contrast, syllable, label)  # Add 'contrast' column for group comparisons

#make factor levels the same for sig syllables and x-axis
sig_syllables_3ct_gee <- sig_syllables_3ct_gee %>%
  mutate(syllable = factor(syllable, levels = syllable_order_3ct_gee))

# Print sig_syllables to check
print(sig_syllables_3ct_gee) 
```

```{r}
# Get syllables in descending order of emmean from the control group
syllable_order_3ct_gee <- emm_df_3ct_gee %>%
  filter(group == "control") %>% 
  arrange(desc(emmean)) %>% #computed mean frequency sorted from most to least
  pull(syllable) %>% # Extract just the ordered syllable names, this controls x-axis of plot
  as.character()

# Reapply the factor with new levels
emm_df_3ct_gee <- emm_df_3ct_gee %>%
  mutate(syllable = factor(syllable, levels = syllable_order_3ct_gee))
emm_df_3ct_gee

```

```{r}
#check if factor ordering is same
levels(emm_df_3ct_gee$syllable)
levels(sig_syllables_3ct_gee$syllable)
```

```{r}
# Create the plot
plot_3ct_gee <- ggplot(emm_df_3ct_gee, aes(x = syllable, y = emmean, color = group, group = group)) +
  # Add lines connecting the means for each group
#  geom_line(size = 1) +
  # Add points at the means for each group
  geom_point(size = 3) +
  # Add error bars for standard error
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  # Custom colors for different groups
  scale_color_manual(values = c("control" = "#feca8d", "post_w1" = "#f1605d", "post_w2" = "#440f76")) +
  scale_x_discrete(labels = syllable_labels_3ct) +
  # Labels for axes and legend
  labs(
    x = "Syllable Order by Frequency",
    y = "Frequency",
    color = NULL
  ) +
  ylim(0, 0.3) +
  # Apply clean theme
  theme_bw() +
  theme(
    text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.box.margin = margin(0, 50, 0, 0),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, margin = margin(b = 0)) #angle of x-axis text below and spacing
    )
# Add significance asterisks
plot_3ct_gee <- plot_3ct_gee + geom_text(
  data = sig_syllables_3ct_gee,
  aes(x = as.numeric(as.factor(syllable)), #(factor makes sure lines up with x-axis syllables)
      # Determine y position based on contrast type
      y = case_when(
        contrast == "control - post_w1" ~ 0.28,
        contrast == "post_w1 - post_w2" ~ 0.24,
        contrast == "control - post_w2" ~ 0.20,
        TRUE ~ 0.20  # Default position for any other contrast
      ),
      label = label),  
  color = "black",
  size = 5,
  inherit.aes = FALSE
)

plot_3ct_gee
#ggsave("3ct_graph(SE)_gee.png", plot = plot_3ct_gee, width = 15, height = 6) #makes spaces visible
```

#robust LLM OFT

```{r}
model_oft_log <- lmer(log(frequency) ~ group * syllable + (1 | ID), data = df_oft)
```

```{r}
#assumption check 1 - Normality of residuals (should be normally distributed) - violates
qqnorm(resid(model_oft_log))
qqline(resid(model_oft_log))
```


```{r}
#Assumption 2 - Homoscedasticity (variance should be consistent) - VIOLATES
plot(fitted(model_oft_log), resid(model_oft_log))
```
```{r}
# Obtain estimated marginal means
emm_oft_log <- emmeans(model_oft_log, ~ group | syllable)  # Pairwise comparisons of syllable effects within each group
head(emm_oft_log)
```

```{r}
#for hetereodtasicity
coef_test(model_oft, vcov = "CR2", cluster = df_oft$ID)
```




